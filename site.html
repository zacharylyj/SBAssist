<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: Arial, sans-serif;
        }

        .logo-container {
            position: absolute;
            top: 0;
            left: 0;
            height: 80px;
            width: auto
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: calc(100vh - 100px);
            /* minus till no scroll if logo increase decrease this*/
            margin: calc(50px + 30px) 0 20px 0;
            gap: 10px;
        }

        .chat-user {
            background-color: #d4f8e8;
            border-radius: 1rem;
            text-align: left;
            max-width: 70%;
            width: auto;
            min-width: 100px;
            margin-left: auto;
            margin-right: 10px;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 16px;
            font-family: Arial, sans-serif;
            border: none;
            outline: none;
            resize: none;
            overflow: hidden;
            white-space: pre-wrap;
        }

        .chat-assistant {
            display: flex;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .chat-assistant img.assistant-logo {
            width: 28px;
            height: 28px;
            margin-right: 2px;
            border-radius: 50%;
            /* This makes the image a circle */
            object-fit: cover;
            /* Ensures the image scales properly within the circle */
        }


        .chat-assistant .assistant-message {
            flex: 1;
            text-align: left;
        }

        .chat-container {
            flex: 1;
            /* Takes up the remaining space */
            width: 100%;
            max-width: 920px;
            min-width: 460px;
            overflow-y: auto;
            padding: 10px;
            border-radius: 5px;

        }

        .chat-message {
            display: flex;
            flex-direction: column;
        }

        .input-container {
            width: 100%;
            max-width: 620px;
            min-width: 460px;
            margin: 0 30px;
            padding: 10px;
            border-radius: 1.5em;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            height: auto;
        }

        .input-bar {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 10px;
            position: relative;
        }

        .input-bar .box {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .file-input-button {
            border: none;
            background-color: transparent;
            cursor: pointer;
            position: relative;
        }

        .file-input-button label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .file-input-button label svg {
            width: 24px;
            height: 24px;
            fill: #666;
            transition: fill 0.2s;
        }

        .file-input-button:hover label svg {
            fill: #58004F;
        }

        .file-input-button input[type="file"] {
            display: none;
        }

        .file-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: #f1f1f1;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            position: relative;
            max-width: 600px;
            width: 100%;
            transition: background-color 0.3s;
        }

        .file-item:hover {
            background-color: #e0e0e0;
            /* Optional: slightly change background color on hover */
        }

        .file-close {
            position: absolute;
            top: -8px;
            right: -8px;
            background-color: #f44336;
            border: none;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            /* Initially hidden */
            align-items: center;
            justify-content: center;
            font-size: 16px;
            line-height: 16px;
            font-weight: bold;
            padding: 0;
            transition: opacity 0.2s ease-in-out;
        }

        .file-item:hover .file-close {
            display: flex;
            /* Show close button on hover */
        }

        .file-close:hover {
            background-color: #d32f2f;
        }

        .file-icon {
            width: 24px;
            height: 24px;
            margin-right: 10px;
            display: flex;
            align-items: center;
        }

        .file-details {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .file-name {
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        .file-type {
            font-size: 12px;
            color: #666;
        }


        .text-input {
            flex: 1;
            font-size: 16px;
            /* Same */
            min-height: 16px;
            /* Same */
            max-height: 180px;
            border-radius: 4px;
            padding: 0;
            margin: auto;
            border: 1px transparent;
            resize: none;
            overflow-y: auto;
            font-feature-settings: "liga" 0;
        }

        .text-input:focus {
            outline: none;
            border: none;
        }

        .send-button {
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 50%;
            background-color: #58004F;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .send-button:hover:not(:disabled) {
            opacity: 0.8;
        }

        .send-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .drag-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: white;
            font-size: 1.5em;
            text-align: center;
            pointer-events: none;
            backdrop-filter: blur(5px);
        }

        .drag-overlay svg {
            width: 50px;
            height: 50px;
            margin-bottom: 10px;
            fill: white;
        }

        .upload-tooltip {
            position: absolute;
            bottom: 35px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.85em;
            white-space: nowrap;
            display: none;
            pointer-events: none;
        }

        .file-input-button:hover .upload-tooltip {
            display: block;
        }

        /* Universal styles for all scrollbars */

        /* Chrome, Edge, Safari */
        *::-webkit-scrollbar {
            width: 6px;
            /* Width of the scrollbar */
            height: 6px;
            /* Height for horizontal scrollbars */
        }

        *::-webkit-scrollbar-track {
            background: #f1f1f1;
            /* Background color of the scrollbar track */
            border-radius: 10px;
            /* Rounded corners on the scrollbar track */
        }

        *::-webkit-scrollbar-thumb {
            background-color: #888;
            /* Color of the scrollbar thumb */
            border-radius: 10px;
            /* Rounded corners on the scrollbar thumb */
            border: 2px solid transparent;
            /* Optionally add space around thumb for better look */
        }

        *::-webkit-scrollbar-thumb:hover {
            background-color: #555;
            /* Darker color when the scrollbar is hovered */
        }

        /* Firefox */
        * {
            scrollbar-width: thin;
            /* Makes the scrollbar thinner */
            scrollbar-color: #888 #f1f1f1;
            /* Thumb color (first), track color (second) */
        }

        /* Optional: make horizontal scrollbar slightly different */
        *::-webkit-scrollbar-horizontal {
            height: 6px;
            /* Adjust height for horizontal scrollbars */
        }

        .no-select {
            user-select: none;
            /* Prevents text selection */
            -webkit-user-select: none;
            /* Safari */
            -moz-user-select: none;
            /* Firefox */
            -ms-user-select: none;
            /* Internet Explorer/Edge */
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.2/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/showdown/dist/showdown.min.js"></script>
</head>

<body>
    <img class="logo-container no-select" src="./assets/lkc_logo.png" alt="LKC Medicine Logo">
    <div class="container">
        <div class="chat-container">
            <div class="chat-message" id="chat-message">
                <!-- Dynamically add assistant user chat messages -->
            </div>
        </div>
        <div class="input-container" id="input-container">
            <div class="file-container" id="fileContainer">
                <!-- Dynamically add File uploaded -->
            </div>
            <div class="input-bar" id="input-bar">
                <div class="box">
                    <div class="file-input-button">
                        <label for="file-input">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path
                                    d="M12 2a2 2 0 0 1 2 2v7h3.586l-4.293-4.293a1 1 0 0 1 1.414-1.414l6 6a1 1 0 0 1 0 1.414l-6 6a 1 1 0 0 1-1.414-1.414L17.586 13H14v7a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h6z" />
                            </svg>
                        </label>
                        <input type="file" id="file-input" multiple accept=".pdf,.txt,.docx,.xlsx" />
                        <div class="upload-tooltip">Upload file</div>
                    </div>
                </div>
                <textarea id="text-input" class="text-input" rows="1" placeholder="Type your message..."></textarea>
                <div class="box">
                    <button id="send-button" class="send-button" disabled>&#9658;</button>
                </div>
            </div>
        </div>
        <div id="drag-overlay" class="drag-overlay" style="display: none;">
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path
                        d="M21.41 11.58l-9-9A1.992 1.992 0 0012 2c-.53 0-1.04.21-1.41.59l-9 9c-.78.78-.78 2.05 0 2.83.78.78 2.05.78 2.83 0L5 13.83V20a2 2 0 002 2h10a2 2 0 0 1 2-2v-6.17l1.58 1.59c.39.39.9.58 1.41.58.51 0 1.02-.19 1.41-.58.78-.78.78-2.05 0-2.83z" />
                </svg>
                Drop .xlsx, .docx, and .txt files to be analysed
            </div>
        </div>
    </div>
    <script>
        // Global Var
        const textInput = document.getElementById("text-input");
        const sendButton = document.getElementById("send-button");
        const inputBar = document.getElementById("input-bar");
        const inputContainer = document.getElementById("input-container");
        const fileInput = document.getElementById("file-input");
        const dragOverlay = document.getElementById("drag-overlay");
        const chatMessageContainer = document.querySelector('.chat-message');
        let ws;
        let assistantMessageDiv
        let currentMarkdown = "";
        let initialArray = [];
        let activeArray = [];
        let maxChatHistory = [];
        const maxHistoryLength = 20 // Number of assistant and user message to send back
        let reconnectInterval = 1000; // 1 seconds
        connectWebSocket();


        function updateHTML(markdown) {
            const converter = new showdown.Converter();
            const html = converter.makeHtml(markdown);

            if (assistantMessageDiv) {
                assistantMessageDiv.innerHTML = html;
            }
            scrollToBottom(); // Ensure the chat box scrolls to the latest message
        }
        function finalizeHTML(markdown) {
            const converter = new showdown.Converter();
            const finalHtml = converter.makeHtml(markdown);

            // Replace textarea content with the final version of the message
            if (assistantMessageDiv) {
                assistantMessageDiv.innerHTML = finalHtml;
            }
            scrollToBottom(); // Ensure the chat box scrolls to the latest message
        }


        function connectWebSocket() {
            ws = new WebSocket('wss://jz92qcvyd4.execute-api.ap-southeast-1.amazonaws.com/prod/');

            ws.onopen = function () {
                console.log('WebSocket connection opened');
            };

            ws.onerror = function (error) {
                console.error('WebSocket error:', error);
            };

            ws.onclose = function () {
                console.log('WebSocket connection closed, attempting to reconnect in ' + reconnectInterval / 1000 + ' seconds...');
                setTimeout(connectWebSocket, reconnectInterval);
            };

            ws.onmessage = function (event) {
                if (!assistantMessageDiv) {
                    // Create a new outer div for chat assistant
                    let chatAssistantDiv = document.createElement('div');
                    chatAssistantDiv.className = 'chat-assistant';

                    // Create the image element
                    let imgElement = document.createElement('img');
                    imgElement.src = './assets/assistant-logo.png';
                    imgElement.alt = 'Assistant Logo';
                    imgElement.className = 'assistant-logo';

                    // Append the image to the outer div
                    chatAssistantDiv.appendChild(imgElement);

                    // Create a new div for the assistant's message
                    assistantMessageDiv = document.createElement('div');
                    assistantMessageDiv.className = 'assistant-message'; // Change class name to avoid conflict

                    // Append the message div to the outer div
                    chatAssistantDiv.appendChild(assistantMessageDiv);

                    // Append the outer div to the chat container
                    chatMessageContainer.appendChild(chatAssistantDiv);
                }
                currentMarkdown += event.data; // Accumulate the streamed markdown data

                updateHTML(currentMarkdown.trim());

                if (event.data.includes('𵵙')) {
                    // If the end of the message is received, finalize the rendering
                    const completeMessage = currentMarkdown.split('𵵙')[0].trim(); // Split and trim correctly
                    finalizeHTML(completeMessage); // Finalize the message with markdown conversion
                    maxChatHistory.push({
                        role: 'assistant',
                        content: completeMessage
                    });
                    currentMarkdown = ""; // Clear for the next message

                    // Reset the textarea so that a new one is created for the next response
                    assistantMessageDiv = null;
                }
            };
        }

        function authenticate() {
            const payload = {
                user: 'LKCadmin@admin.com',
                password: 'LKCMedcine2024!'
            };
            console.log("Starting authentication...");

            return fetch('https://r6i2hvxhknzoe7shxuhnfk2i6e0mgkbh.lambda-url.ap-southeast-1.on.aws/get-key', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload),
            })
                .then(response => response.text())  // Returning the response as text
                .then(data => {
                    return data;  // Returning the data to the calling context
                })
                .catch(error => {
                    console.error('Error during authentication:', error);
                    throw error;  // Rethrow the error to the calling context
                });
        }
        async function callAuthentication() {
            try {
                const result = await authenticate();  // Waits for the authentication result
                console.log('Received authentication result');
                return result
                // Handle the returned result here
            } catch (error) {
                console.error('Authentication failed:', error);
            }
        }

        function scrollToBottom() {
            const chatContainer = document.querySelector('.chat-container');
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function hasContent(array) {
            return array.length > 0;
        }
        function replaceAndEmpty(array1, array2) {
            array2.length = 0; // Clear array2
            array2.push(...array1); // Copy elements from array1 to array2
            // Empty array1
            array1.length = 0;
        }
        function isWebSocketConnected() {
            return ws && ws.readyState === WebSocket.OPEN; // Check if WebSocket is in the 'OPEN' state
        }
        function createUserMessage(text) {
            // Create the textarea element
            const textArea = document.createElement('textarea');
            textArea.className = 'chat-user';
            textArea.readOnly = true; // Prevent user editing
            chatMessageContainer.appendChild(textArea);

            // Function to auto-resize the textarea
            function autoResize() {
                textArea.style.height = 'auto'; // Reset height
                textArea.style.height = (textArea.scrollHeight - 18) + 'px'; // Set height based on content
            }

            // Calculate total time and dynamically adjust chunk size and delay
            const totalDuration = 100; // Total time to display in milliseconds (3.5 seconds)
            const textLength = text.length;

            // Calculate chunk size based on the length of the text
            let chunkSize = Math.max(Math.floor(textLength / 100), 1); // Ensure at least 1 character per chunk

            let typingDelay = totalDuration / (textLength / chunkSize);

            // Function to "stream" the message character by character
            let index = 0;
            function typeWriter() {
                if (index < text.length) {
                    textArea.value += text.substring(index, index + chunkSize);
                    autoResize(); // Adjust height after adding new content
                    index += chunkSize; // Move index forward by chunk size
                    setTimeout(typeWriter, typingDelay); // Adjust delay dynamically
                    scrollToBottom(); // Keep scrolling to the bottom if needed
                }
            }
            // Start the typing animation
            typeWriter();
        }

        async function sendMessage() {
            let userMessage = "Rag Items:\n"
            const message = textInput.value.trim();
            createUserMessage(message)

            const chatHistory = maxChatHistory.slice(-maxHistoryLength + 1)
            if (message) {
                console.log("Message sent: ", message); // log
                textInput.value = "";
                textInput.style.height = "20px";
                sendButton.disabled = true;
                if (hasContent(initialArray)) {
                    replaceAndEmpty(initialArray, activeArray);
                    renderFileItems()
                }
                for (let file of activeArray) {
                    try {
                        // Send message and file content to getRagExtract
                        const ragtext = await getRagExtract(message, file.content);
                        userMessage += `Rag Data from ${file.fileName}: ${ragtext}\n\n`
                    } catch (error) {
                        console.error(`Error while processing file: ${file.fileName}`, error);
                    }
                }
                if (!isWebSocketConnected()) {
                    console.log('WebSocket is not connected. Reconnecting...');
                    connectWebSocket();

                    // Wait for the WebSocket to be ready before sending the message
                    const waitForConnection = new Promise((resolve) => {
                        ws.onopen = () => {
                            console.log('WebSocket reconnected, sending message...');
                            resolve();
                        };
                    });

                    await waitForConnection; // Wait until the WebSocket reconnects
                }
                userMessage += `User Query: ${message}`
                // Add in custtom message
                try {
                    sys_prompt = `
Use markdown format only:
                    `
                    const authkey = await callAuthentication();
                    const request_llm = {
                        "action": "stream",
                        "deployment_name": "gpt4-Omni",
                        "key": authkey,
                        "sys_instruct": sys_prompt,
                        "user_request": userMessage,
                        "extended_content": [...chatHistory.slice(-maxHistoryLength + 1)]
                    };
                    console.log('Sending message to server:', message);
                    ws.send(JSON.stringify(request_llm));
                    maxChatHistory.push({
                        role: 'user',
                        content: userMessage
                    });
                    console.log(maxChatHistory);

                } catch (error) {
                    console.error("Error querying Lambda:", error); // Enhanced error logging
                    return null;
                }
            }
        }

        async function getRagExtract(query, data) {
            const content = `
User Query: ${query}
Data: ${data}
`
            let dataContent = ""
            const response = await fetch('https://mmzaorzrkjnikxr7ijfrt4tdfe0sndwi.lambda-url.ap-southeast-1.on.aws/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    messages: [{
                        role: 'user',
                        content: content
                    }],
                    azure_model_endpoint: 'gpt4-Omni'
                }),
            });

            console.log('Handshake:', response);
            if (!response.body) {
                console.error('No response body');
                return;
            }
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let done = false;

            console.log('Starting to read the stream...');

            while (!done) {
                const {
                    value,
                    done: doneReading
                } = await reader.read();
                done = doneReading;
                let chunk = decoder.decode(value, {
                    stream: true
                });
                dataContent += chunk;
                console.log("Chunk: ", chunk);
            }
            return dataContent
        }
        function renderFileItems() {
            console.log("Rendering Files")
            const fileContainer = document.getElementById('fileContainer');
            fileContainer.innerHTML = ''; // Clear the container before re-rendering

            initialArray.forEach((file, index) => {
                // Create the file item container
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';

                // Create the close button
                const closeButton = document.createElement('button');
                closeButton.className = 'file-close';
                closeButton.innerHTML = '&times;'; // Close icon
                closeButton.onclick = () => {
                    initialArray.splice(index, 1); // Remove the file from the array
                    renderFileItems(); // Re-render the file items
                };

                // Create the file icon
                const fileIcon = document.createElement('div');
                fileIcon.className = 'file-icon';
                fileIcon.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a2 2 0 0 1 2 2v7h3.586l-4.293-4.293a1 1 0 0 1 1.414-1.414l6 6a1 1 0 0 1 0 1.414l-6 6a1 1 0 0 1-1.414-1.414L17.586 13H14v7a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h6z"/></svg>`;

                // Create the file name and type container
                const fileDetails = document.createElement('div');
                fileDetails.className = 'file-details';
                fileDetails.innerHTML = `<span class="file-name">${file.fileName}</span> <span class="file-type">(${file.fileName.split('.').pop()})</span>`;

                // Append close button, file icon, and file details to the file item
                fileItem.appendChild(closeButton);
                fileItem.appendChild(fileIcon);
                fileItem.appendChild(fileDetails);

                // Append the file item to the file container
                fileContainer.appendChild(fileItem);
            });
        }
        function handleFileUpload(files) {
            uploadFile(files);
        }

        async function uploadFile(files) {
            for (const file of files) {
                let extractedText = "";

                if (file.type === "application/pdf") {
                    const fileData = await readFileAsArrayBuffer(file);
                    extractedText = await extractTextFromPdf(fileData);
                } else if (file.type === "text/plain") {
                    extractedText = await readFileAsText(file);
                } else if (file.type === "application/vnd.openxmlformats-officedocument.wordprocessingml.document") {
                    const fileData = await readFileAsArrayBuffer(file);
                    extractedText = await extractTextFromDocx(fileData);
                }

                if (extractedText) {
                    initialArray.push({
                        fileName: file.name,
                        content: extractedText
                    });
                    console.log("File processed: ", file.name);
                    console.log("Extracted content: ", extractedText);
                }
                renderFileItems()
            }
        }

        function readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        async function extractTextFromPdf(arrayBuffer) {
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            let text = "";
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const content = await page.getTextContent();
                text += content.items.map(item => item.str).join(" ") + "\n";
            }
            return text;
        }

        async function extractTextFromDocx(arrayBuffer) {
            const zip = await JSZip.loadAsync(arrayBuffer);
            const xml = await zip.file("word/document.xml").async("text");
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xml, "application/xml");
            const paragraphs = xmlDoc.getElementsByTagName("w:t");
            let text = "";
            for (let i = 0; i < paragraphs.length; i++) {
                text += paragraphs[i].textContent + " ";
            }
            return text;
        }

        // Drag and drop file upload
        inputContainer.addEventListener("dragover", (event) => {
            event.preventDefault();
            dragOverlay.style.display = "flex";
        });

        inputContainer.addEventListener("dragleave", () => {
            dragOverlay.style.display = "none";
        });

        inputContainer.addEventListener("drop", (event) => {
            event.preventDefault();
            dragOverlay.style.display = "none";
            if (event.dataTransfer.files.length) {
                handleFileUpload(event.dataTransfer.files);
            }
        });

        fileInput.addEventListener("change", (event) => {
            if (event.target.files.length) {
                handleFileUpload(event.target.files);
            }
        });
        // Global drop handler to hide overlay if dragging out of the window
        window.addEventListener("dragover", (event) => {
            event.preventDefault();
        });

        window.addEventListener("drop", () => {
            dragOverlay.style.display = "none";
        });
        // Toggle send button enabled state based on input
        textInput.addEventListener("input", () => {
            textInput.style.height = "20px";
            textInput.style.height = Math.min(textInput.scrollHeight, 180) + "px";
            sendButton.disabled = textInput.value.trim() === "";
        });

        // Add shift+enter for a new line
        textInput.addEventListener("keydown", (event) => {
            if (event.key === "Enter" && !event.shiftKey) {
                event.preventDefault();
                if (!sendButton.disabled) {
                    sendMessage();
                }
            }
        });

        // Send button click handler
        sendButton.addEventListener("click", sendMessage);

    </script>
</body>

</html>